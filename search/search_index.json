{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Page d'accueil","text":"<p>Thomas Blatti (Thomas.Blatti@heig-vd.ch)  </p> <p>Ce site est con\u00e7u comme un outil de stockage de prise de notes  pour les cours. Il permet de cr\u00e9er, \u00e9diter et organiser  facilement des notes de cours dans un format structur\u00e9.  Adapt\u00e9 pour les \u00e9tudiants qui souhaitent optimiser leur  gestion de notes, cet outil vise \u00e0 am\u00e9liorer l'efficacit\u00e9  de l'apprentissage et la r\u00e9vision.</p>"},{"location":"#sommaires","title":"Sommaires :","text":"<p>Prise de notes language C Prise de notes language Python Prise de notes Math MT</p>"},{"location":"cours_info_C/","title":"Prise de notes en C","text":""},{"location":"cours_info_C/#bibliotheques-standard-du-c","title":"Biblioth\u00e8ques Standard du C","text":""},{"location":"cours_info_C/#gestion-des-erreurs-et-assertions","title":"=== Gestion des Erreurs et Assertions ===","text":"<pre><code>#include &lt;assert.h&gt; --&gt; Gestion des assertions \n</code></pre> <pre><code>#include &lt;errno.h&gt; --&gt; Codes d'erreur standard \n</code></pre>"},{"location":"cours_info_C/#types-et-limites","title":"=== Types et Limites ===","text":"<pre><code>#include &lt;complex.h&gt; --&gt; Op\u00e9rations sur des nombres complexes \n</code></pre> <pre><code>#include &lt;ctype.h&gt; --&gt; Fonctions de test et de mappage de caract\u00e8res    \n</code></pre> <pre><code>#include &lt;float.h&gt; --&gt; Limites des types \u00e0 virgule flottante    \n</code></pre> <pre><code>#include &lt;inttypes.h&gt; --&gt; Types entiers avec largeur fixe \n</code></pre> <pre><code>#include &lt;limits.h&gt; --&gt; Limites des types fondamentaux   \n</code></pre> <pre><code>#include &lt;stdbool.h&gt; --&gt; Types bool\u00e9en \n</code></pre> <pre><code>#include &lt;stddef.h&gt; --&gt; D\u00e9finitions de types et de macros g\u00e9n\u00e9rales  \n</code></pre> <pre><code>#include &lt;stdint.h&gt; --&gt; Types entiers \u00e0 largeur fixe  \n</code></pre>"},{"location":"cours_info_C/#localisation-et-environnement","title":"=== Localisation et Environnement ===","text":"<pre><code>#include &lt;locale.h&gt; --&gt; Localisation \n</code></pre> <pre><code>#include &lt;fenv.h&gt; --&gt; Gestion de l'environnement flottant   \n</code></pre> <pre><code>#include &lt;setjmp.h&gt; --&gt; Gestion des rebonds d'environnement non local \n</code></pre> <pre><code>#include &lt;signal.h&gt; --&gt; Gestion des signaux \n</code></pre>"},{"location":"cours_info_C/#entreessorties-et-manipulation-de-chaines","title":"=== Entr\u00e9es/Sorties et Manipulation  de Cha\u00eenes ===","text":"<pre><code>#include &lt;stdio.h&gt; --&gt; Entr\u00e9e/Sortie  \n</code></pre> <pre><code>#include &lt;stdlib.h&gt; --&gt; Utilitaires g\u00e9n\u00e9raux\n</code></pre> <pre><code>#include &lt;string.h&gt; --&gt; Manipulation de cha\u00eenes \n</code></pre>"},{"location":"cours_info_C/#fonctions-mathematiques","title":"=== Fonctions Math\u00e9matiques ===","text":"<pre><code>#include &lt;math.h&gt; --&gt; Fonctions math\u00e9matiques   \n</code></pre> <pre><code>#include &lt;tgmath.h&gt; --&gt; Fonctions math\u00e9matiques g\u00e9n\u00e9riques\n</code></pre>"},{"location":"cours_info_C/#gestion-du-temps","title":"=== Gestion du Temps ===","text":"<pre><code>#include &lt;time.h&gt; --&gt; Fonctions li\u00e9es au temps\n</code></pre>"},{"location":"cours_info_C/#arguments-variables","title":"=== Arguments Variables ===","text":"<pre><code>#include &lt;stdarg.h&gt; --&gt; Gestion des arguments \u00e0 nombre variable\n</code></pre>"},{"location":"cours_info_C/#types-de-variables-du-c","title":"Types de variables du C","text":"<pre><code>char a;  --&gt; Entier sur 8 bits utilis\u00e9 pour des caract\u00e8res.\n\nshort b; --&gt; short int: Entier en g\u00e9n\u00e9ral sur 16 bits.\n\nint c;   --&gt; Entier en g\u00e9n\u00e9ral sur 16 ou 32 bits, d\u00e9pendant du syst\u00e8me et du compilateur.\n\nlong d;\n\nlong int e; --&gt; Entier en g\u00e9n\u00e9ral sur 32 bits.\n\nlong long f;\n\nlong long int g; --&gt; Entier sur 64 bits.\n</code></pre>"},{"location":"cours_info_C/#types-a-virgule-flottante","title":"=== Types \u00e0 Virgule Flottante ===","text":"<pre><code>float h; --&gt; Approximation de r\u00e9els, sur 32 bits\n            (1 bit de signe, 8 bits pour l'exposant et 23 bits pour la fraction).\n\ndouble i; --&gt; Approximation de r\u00e9els sur 64 bits (1 bit de signe, 11 bits\n              pour l'exposant et 52 bits pour la fraction).\n\nlong double j; --&gt; Approximation de r\u00e9els sur min. 80 bits, mais souvent\n                   128 bits (1 bit de signe, 15 bits pour l'exposant et 112 bits pour la fraction).\n</code></pre>"},{"location":"cours_info_C/#formatage-pour-printf-en-c","title":"Formatage pour printf en C","text":"<pre><code>  * %d, %i      : int en base 10  \n  * %c          : caract\u00e8re donn\u00e9 par son code de type int  \n  * %f          : double, par d\u00e9faut 6 chiffres significatifs  \n  * %e, %E      : double en notation scientifique avec e ou E  \n  * %g, %G      : choix automatique entre %f et %e ou entre %f et %E  \n  * %s          : cha\u00eene de caract\u00e8res  \n  * %u          : unsigned int  \n  * %o, %x, %X  : int affich\u00e9e en octal ou en hexad\u00e9cimal  \n  * %p          : adresse  \n  * %%          : le caract\u00e8re % lui-m\u00eame  \n</code></pre>"},{"location":"cours_info_C/#flags","title":"=== Flags ===","text":"<pre><code>- (flag)    : alignement \u00e0 gauche\n+ (flag)    : nombres imprim\u00e9s avec le signe (sinon seul le signe n\u00e9gatif est imprim\u00e9)\n0 (flag)    : ajoute des z\u00e9ros devant\n# (flag)    : avec type o, x, et X force l'\u00e9criture de 0, 0x ou 0X\n\ndevant. Avec f, e, E force le point d\u00e9cimal.\n\nWidth:\nnombre ou * : nombre minimum de caract\u00e8res utilis\u00e9s pour l\u2019impression (ajout d'espaces)\n\nPrecision:\n.nombre ou *: nombre de chiffres apr\u00e8s la virgule\n\nLength:\nl           : pour un entier long (ou L pour un long double), h pour un entier court\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-manipulation-de-fichiers-en-c","title":"Fonctions de Manipulation de Fichiers en C","text":"<pre><code>int fputc(int c, FILE *fp); --&gt; \u00c9crit un caract\u00e8re 'c' dans le fichier point\u00e9 par 'fp'.\n                                 Retourne le caract\u00e8re \u00e9crit en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>int fgetc(FILE *fp); --&gt; Lit et retourne le prochain caract\u00e8re sous forme d'int\n                         depuis le fichier point\u00e9 par 'fp' ou EOF en cas d'erreur ou de fin de fichier.\n</code></pre> <pre><code>int ungetc(int char, FILE *fp); --&gt; Remet le caract\u00e8re 'char' dans le flux de 'fp', le rendant\n                                    disponible pour la prochaine lecture avec fgetc(). Retourne\n                                    le caract\u00e8re en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>int fputs(const char *s, FILE *fp); --&gt; \u00c9crit la cha\u00eene 's' dans le fichier point\u00e9\n                                          par 'fp' (le '\\n' n'est pas n\u00e9cessaire). Retourne une\n                                          valeur non n\u00e9gative en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>char *fgets(char *buf, int n, FILE *fp); --&gt; Lit au maximum 'n-1' caract\u00e8res depuis le fichier 'fp', les\n                                             stocke dans 'buf', et ajoute un '\\0' final. S'arr\u00eate \u00e0 '\\n'\n                                             ou \u00e0 la fin du fichier. Retourne 'buf' en cas de succ\u00e8s, sinon NULL.\n</code></pre> <pre><code>int fprintf(FILE *fp, const char *format, ...); --&gt; \u00c9crit des donn\u00e9es format\u00e9es dans le fichier 'fp' selon le 'format'\n                                                     sp\u00e9cifi\u00e9, comme printf mais dans un fichier. Retourne le nombre de\n                                                     caract\u00e8res \u00e9crits, ou une valeur n\u00e9gative en cas d'\u00e9chec.\n</code></pre> <pre><code>int fscanf(FILE *fp, const char *format, ...); --&gt; Lit des donn\u00e9es format\u00e9es depuis le fichier 'fp' selon le 'format'\n                                                    sp\u00e9cifi\u00e9, comme scanf mais depuis un fichier. Retourne le\n                                                    nombre d'\u00e9l\u00e9ments lus, 0 en cas d'erreur, ou EOF pour une fin de fichier.\n</code></pre> <pre><code>void rewind(FILE *fp); --&gt;Repositionne le curseur de fichier 'fp' au d\u00e9but du fichier.\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-gestion-avancee-des-fichiers-en-c","title":"=== Fonctions de Gestion Avanc\u00e9e des Fichiers en C ===","text":"<pre><code>int fflush(FILE *fp); --&gt; Vide le buffer de sortie du fichier point\u00e9 par 'fp' et\n                            \u00e9crit toutes les donn\u00e9es en attente.\n                            Retourne 0 en cas de succ\u00e8s, EOF en cas d'erreur.\n</code></pre> <pre><code>fflush(NULL); --&gt; Vide tous les buffers de sortie de tous les fichiers ouverts.\n</code></pre> <pre><code>int remove(const char *filename); --&gt; Supprime le fichier d\u00e9sign\u00e9 par 'filename'. Retourne 0 en cas\n                                        de succ\u00e8s, -1 en cas d'erreur et\n                                        d\u00e9finit errno.\n</code></pre> <pre><code>int rename(const char *old_filename, const char *new_filename); --&gt; Renomme le fichier 'old_filename' en 'new_filename'. Retourne 0\n                                                                      en cas de succ\u00e8s, -1 en cas\n                                                                      d'erreur et d\u00e9finit errno.\n</code></pre> <pre><code>FILE *tmpfile(void); --&gt; Cr\u00e9e un fichier temporaire en mode \"wb+\" qui sera supprim\u00e9\n                           automatiquement \u00e0 la fin de l'ex\u00e9cution du programme.\n                           Retourne un pointeur vers ce fichier en cas de succ\u00e8s, ou NULL en cas d'\u00e9chec.\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-verification-et-de-reinitialisation-de-letat-des-fichiers-en-c","title":"=== Fonctions de V\u00e9rification et de R\u00e9initialisation de l'\u00c9tat des Fichiers en C ===","text":"<pre><code>void clearerr(FILE *fp); --&gt; Efface les indicateurs d'erreur et de fin de fichier associ\u00e9s au\n                               fichier point\u00e9 par 'fp'.\n</code></pre> <pre><code>int feof(FILE *fp); --&gt; Teste l'indicateur de fin de fichier pour le fichier point\u00e9 par 'fp' et\n                          renvoie un r\u00e9sultat non nul si celui-ci est positionn\u00e9, 0 sinon.\n</code></pre> <pre><code>int ferror(FILE *fp); --&gt; Teste l'indicateur d'erreur pour le fichier point\u00e9 par 'fp' et renvoie un\n                            r\u00e9sultat non nul si celui-ci est positionn\u00e9, 0 sinon.\n</code></pre>"},{"location":"cours_info_C/#structures-et-creation-de-types-en-c","title":"Structures et Cr\u00e9ation de Types en C","text":"<ul> <li> <p>D\u00e9finition d'une structure   <code>struct NomStructure {       type membre1;         --&gt; Permet de regrouper plusieurs variables de types diff\u00e9rents sous le m\u00eame type.       type membre2;      };</code></p> </li> <li> <p>Cr\u00e9ation d'une instance de structure    <code>struct NomStructure variable; --&gt; D\u00e9clare une variable de type 'struct NomStructure'.</code></p> </li> <li> <p>Acc\u00e8s aux membres d'une structure    <code>variable.membre1 = valeur; --&gt; Acc\u00e8de et modifie le membre 'membre1' de la structure 'variable'.</code></p> </li> <li> <p>Pointeur sur une structure    <code>struct NomStructure *ptr = &amp;variable; --&gt; Cr\u00e9e un pointeur 'ptr' vers la structure 'variable'.</code></p> </li> <li> <p>Acc\u00e8s aux membres d'une structure via un pointeur    <code>ptr-&gt;membre1 = valeur; --&gt; Acc\u00e8de et modifie le membre 'membre1' via le pointeur 'ptr'.</code></p> </li> <li> <p>Typedef pour les structures    <code>typedef struct NomStructure AliasStructure; --&gt; Permet de d\u00e9finir un alias 'AliasStructure' pour 'struct NomStructure'.</code></p> </li> <li> <p>Utilisation de l'alias de structure    <code>AliasStructure nouvelleVariable; --&gt; D\u00e9clare une variable 'nouvelleVariable' de type 'AliasStructure'.</code></p> </li> <li> <p>D\u00e9finition d'un type enum    <code>enum NomEnum { CONST1, CONST2, ... }; --&gt; Permet de d\u00e9finir un ensemble de constantes enti\u00e8res nomm\u00e9es.</code></p> </li> <li> <p>Utilisation d'un enum    <code>enum NomEnum variableEnum = CONST1; --&gt; D\u00e9clare une variable 'variableEnum' de type 'enum NomEnum' et                                           l'initialise avec 'CONST1'.</code></p> </li> </ul>"},{"location":"cours_info_python/","title":"Prise de notes en Python","text":""},{"location":"cours_info_python/#affichage-en-python","title":"Affichage en python","text":"<p>Pour afficher une valeur, on utilise la fonction print(). Cette fonction peut prendre plusieurs param\u00e8tres, s\u00e9par\u00e9s par des virgules. Elle affiche les valeurs s\u00e9par\u00e9es par un espace et ajoute un retour \u00e0 la ligne \u00e0 la fin.</p> <pre><code>print(\"Hello\", \"World\")\n</code></pre> <p>Pour afficher la valeur d\u2019une variable, nous allons utiliser le formatage f-string. Il suffit de pr\u00e9fixer la cha\u00eene de caract\u00e8res avec la lettre f et d\u2019entourer le nom de la variable avec des accolades {}.</p> <pre><code>name = \"World\"\nprint(f\"Hello {name}\")\n</code></pre> <p>Pour afficher un nombre \u00e0 virgule flottante avec un nombre de d\u00e9cimales limit\u00e9, on peut utiliser la notation suivante: {variable:.xf} o\u00f9 x est le nombre de d\u00e9cimales souhait\u00e9.</p> <pre><code>pi = 3.141592653589793\nprint(f\"Pi: {pi:.2f}\")\n</code></pre> <p>La fonction print permet \u00e9galement d\u2019afficher des listes, des tuples, des ensembles et des dictionnaires.</p>"},{"location":"cours_info_python/#chaine","title":"Cha\u00eene","text":"<p>Par rapport au C, les cha\u00eenes de caract\u00e8res sont des objets \u00e0 part enti\u00e8re en Python. Elles poss\u00e8dent de nombreuses m\u00e9thodes qui permettent de les manipuler. link</p> <pre><code>s = \"Hello World\"\nprint(s)        #affiche la string (s)\n\nprint(len(s))   # Affiche la longueur de la cha\u00eene de caract\u00e8res\n\nprint(s.upper())  #affiche la longueur de la string(s) (nombre de caractere)\n\ns1 = \"Hello\"\ns2 = \"World\"\n\nfull = s1 + \" \" + s2    #ajout de deux string pour en donner une seule (Hello + World)\nprint(full)             #affiche la string full\n</code></pre>"},{"location":"cours_info_python/#dictionnaires","title":"Dictionnaires","text":"<p>Un dictionnaire est une collection d\u2019objets non ordonn\u00e9s, modifiables et index\u00e9s. Les dictionnaires sont d\u00e9clar\u00e9s en utilisant des accolades {} et les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par des virgules ,. Chaque \u00e9l\u00e9ment est constitu\u00e9 d\u2019une cl\u00e9 et d\u2019une valeur s\u00e9par\u00e9es par deux points :. Les cl\u00e9s doivent \u00eatre#uniques et immuables (cha\u00eenes, nombres ou tuples).</p> <p>Les m\u00e9thodes suivantes sont disponibles pour les dictionnaires: </p> <pre><code>clear(): supprime tous les \u00e9l\u00e9ments du dictionnaire\n\ncopy(): renvoie une copie du dictionnaire\n\nget(): renvoie la valeur de la cl\u00e9 sp\u00e9cifi\u00e9e\n\nitems(): renvoie une liste contenant une paire de tuples pour chaque paire cl\u00e9-valeur\n\nkeys(): renvoie une liste contenant les cl\u00e9s du dictionnaire\n\npop(): supprime l\u2019\u00e9l\u00e9ment avec la cl\u00e9 sp\u00e9cifi\u00e9e\n\npopitem(): supprime le dernier \u00e9l\u00e9ment ins\u00e9r\u00e9\n\nupdate(): met \u00e0 jour le dictionnaire avec les paires cl\u00e9-valeur sp\u00e9cifi\u00e9es\n\nvalues(): renvoie une liste de toutes les valeurs du dictionnaire\n\nfrench = {\"un\": \"one\", \"deux\": \"two\", \"trois\": \"three\"}\n\nkey = {1: \"one\", 2: \"two\", 3: \"three\"}\n</code></pre>"},{"location":"cours_info_python/#ensembles","title":"Ensembles","text":"<p>Un ensemble est une collection d\u2019objets non ordonn\u00e9s et non index\u00e9s. Les ensembles sont d\u00e9clar\u00e9s en utilisant des accolades {} et les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par des virgules ,. Les ensembles sont utilis\u00e9s lorsque l\u2019ordre des \u00e9l\u00e9ments n\u2019a pas d\u2019importance et que chaque \u00e9l\u00e9ment doit \u00eatre unique. Les ensembles sont plus performants que les listes pour tester l\u2019appartenance d\u2019un \u00e9l\u00e9ment. Il n\u2019est pas possible d\u2019acc\u00e9der \u00e0 un \u00e9l\u00e9ment d\u2019un ensemble par son index.</p> <p>Les m\u00e9thodes suivantes sont disponibles pour les ensembles: link</p> <pre><code>add(): ajoute un \u00e9l\u00e9ment \u00e0 l\u2019ensemble\n\nclear(): supprime tous les \u00e9l\u00e9ments de l\u2019ensemble\n\ncopy(): renvoie une copie de l\u2019ensemble\n\nupdate(): ajoute plusieurs \u00e9l\u00e9ments \u00e0 l\u2019ensemble\n\npop(): supprime un \u00e9l\u00e9ment de l\u2019ensemble\n\nremove(): Supprime un \u00e9l\u00e9ment sp\u00e9cifique de l\u2019ensemble\n\nnumbers = {1, 2, 3, 4, 5}\n</code></pre>"},{"location":"cours_info_python/#listes","title":"Listes","text":"<p>Une liste est une collection d\u2019objets ordonn\u00e9s et modifiables. Les listes sont d\u00e9clar\u00e9es en utilisant des crochets [] et les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par des virgules ,. Une liste en python est polymorphe, c\u2019est-\u00e0-dire qu\u2019elle peut contenir des \u00e9l\u00e9ments de diff\u00e9rents types.</p> <p>Une liste de m\u00e9thodes utiles :</p> <pre><code>append(): ajoute un \u00e9l\u00e9ment \u00e0 la fin de la liste\n\ninsert(): ins\u00e8re un \u00e9l\u00e9ment \u00e0 une position donn\u00e9e\n\nremove(): supprime un \u00e9l\u00e9ment de la liste\n\npop(): supprime un \u00e9l\u00e9ment \u00e0 une position donn\u00e9e\n\nclear(): supprime tous les \u00e9l\u00e9ments de la liste\n\nindex(): renvoie la position d\u2019un \u00e9l\u00e9ment\n\ncount(): renvoie le nombre d\u2019\u00e9l\u00e9ments ayant une valeur donn\u00e9e\n\nsort(): trie les \u00e9l\u00e9ments de la liste\n\nreverse(): inverse l\u2019ordre des \u00e9l\u00e9ments de la liste\n\ncopy(): renvoie une copie de la liste\n\n\nnumbers = [1, 2, 3, 4, 5]\nval = numbers[0] # val = 1\n## Attention, acc\u00e8s au dernier \u00e9l\u00e9ment\nlast = numbers[-1] # last = 5\npoly = [1, 2.5, \"Hello\", True]\nnumbers.append(6) # numbers = [1, 2, 3, 4, 5, 6]\nprint(numbers)\n</code></pre>"},{"location":"cours_info_python/#slices","title":"Slices","text":"<p>Les slices permettent d\u2019extraire une partie d\u2019une liste, d\u2019un tuple ou d\u2019une cha\u00eene de caract\u00e8res. La syntaxe est la suivante: [start:stop:step] o\u00f9 - start est l\u2019indice de d\u00e9part, - stop est l\u2019indice de fin (non inclus) - step est le pas.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nprint(numbers[1:3])\nprint(numbers[1:])\nprint(numbers[:3])\nprint(numbers[::2])\nprint(numbers[::-1])\nprint(numbers[4:1:-1]) \ns = \"Hello World\"\nprint(s[0:3]) # Hel\nprint(s[-1]) # d\n</code></pre> <p>Il est possible d\u2019utiliser des valeurs n\u00e9gatives pour start et stop. Dans ce cas, l\u2019indice est compt\u00e9 \u00e0 partir de la fin de la liste.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nprint(numbers[:-3])\nprint(numbers[-3:-1])\nprint(numbers[-4:])\nprint(numbers[-2:])\n</code></pre> <p>Il est aussi possible d\u2019utiliser des valeurs n\u00e9gatives pour step. Dans ce cas, la liste est parcourue en partant de la fin.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nprint(numbers[::-1])\nprint(numbers[4:1:-1])\nprint(numbers[-1:-4:-1])\n</code></pre>"},{"location":"cours_info_python/#tuples","title":"Tuples","text":"<p>Un tuple est une collection d\u2019objets ordonn\u00e9s et non modifiables. Les tuples sont d\u00e9clar\u00e9s en#utilisant des parenth\u00e8ses () et les \u00e9l\u00e9ments sont s\u00e9par\u00e9s par des virgules ,. Un tuple en python est polymorphe, c\u2019est-\u00e0-dire qu\u2019il peut contenir des \u00e9l\u00e9ments de diff\u00e9rents types.</p> <pre><code>numbers = (1, 2, 3, 4, 5)\nval = numbers[0] # val = 1\n</code></pre> <p>Comme un tuple est non modifiable, il n\u2019y a pas de m\u00e9thode pour ajouter ou supprimer des \u00e9l\u00e9ments. L\u2019instruction numbers[0] = 10 va g\u00e9n\u00e9rer une erreur.</p>"},{"location":"cours_info_python/#types","title":"Types","text":"<pre><code>int\ni = 12\n\nfloat\nf = 12.0\n\ncomplex\nc = 12 + 0j\n\nbool\nb = True\n\nstring\ns1 = \"Hello World\"\n\nlist\nl = [1,2,3,4,5]\n\ntuple\nt = (1,2,3,4,5)\n\nset\ns2 = {1,2,3,4,5}\n\ndict\nd = {\"a\": 13, \"b\": 2, \"c\" : 3}\n</code></pre>"},{"location":"cours_mathmt/","title":"Prise de notes Math MT","text":"<p>Voici un document complet qui int\u00e8gre des exemples d\u00e9taill\u00e9s de r\u00e9solution pour chacun des th\u00e8mes mentionn\u00e9s dans votre test de math\u00e9matiques :</p>"},{"location":"cours_mathmt/#1-methode-de-gauss-pour-les-systemes-lineaires","title":"1. M\u00e9thode de Gauss pour les Syst\u00e8mes Lin\u00e9aires","text":"<p>Exemple: R\u00e9soudre le syst\u00e8me suivant en utilisant la m\u00e9thode de Gauss.  </p>"},{"location":"cours_mathmt/#resolution","title":"R\u00e9solution:","text":"<ol> <li>Forme matricielle et op\u00e9rations \u00e9l\u00e9mentaires pour obtenir une forme \u00e9chelonn\u00e9e:     </li> <li>Diviser la premi\u00e8re ligne par 2.</li> <li>Soustraire le double de la premi\u00e8re ligne de la deuxi\u00e8me ligne et ajouter la premi\u00e8re ligne \u00e0 la troisi\u00e8me ligne.</li> <li> <p>R\u00e9duire la troisi\u00e8me ligne pour obtenir un pivot.</p> </li> <li> <p>La forme \u00e9chelonn\u00e9e r\u00e9duite permet de trouver que , puis remonter pour trouver  et .</p> </li> </ol>"},{"location":"cours_mathmt/#2-systeme-singulier","title":"2. Syst\u00e8me Singulier","text":"<p>Exemple: V\u00e9rifier si le syst\u00e8me suivant est singulier et pourquoi.  </p>"},{"location":"cours_mathmt/#resolution_1","title":"R\u00e9solution:","text":"<ol> <li>Forme matricielle:     </li> <li>\u00c9chelonnage:</li> <li> <p>Les lignes sont proportionnelles, indiquant une matrice de rang 1.</p> </li> <li> <p>Conclusion:</p> </li> <li>Le syst\u00e8me est singulier car il n'a pas de solution unique (il a une infinit\u00e9 de solutions ou aucune, selon les termes constants).</li> </ol>"},{"location":"cours_mathmt/#3-methode-de-cramer","title":"3. M\u00e9thode de Cramer","text":"<p>Exemple: R\u00e9soudre le syst\u00e8me suivant en utilisant la m\u00e9thode de Cramer, si possible.  </p>"},{"location":"cours_mathmt/#resolution_2","title":"R\u00e9solution:","text":"<ol> <li>Matrice des coefficients  et d\u00e9terminant :     </li> <li> <p>Calculons .</p> </li> <li> <p>D\u00e9terminants pour :</p> </li> <li> <p>Rempla\u00e7ons les colonnes respectives par le vecteur des termes constants et calculons les d\u00e9terminants.</p> </li> <li> <p>Application de la m\u00e9thode de Cramer:</p> </li> <li> , et de m\u00eame pour  et .</li> </ol>"},{"location":"cours_mathmt/#4-developpement-limite-dordre-n-pour-taylor","title":"4. D\u00e9veloppement Limit\u00e9 d'ordre n pour Taylor","text":"<p>Exemple: D\u00e9veloppement limit\u00e9 de la fonction  autour de  jusqu'\u00e0 l'ordre 5.</p>"},{"location":"cours_mathmt/#resolution_3","title":"R\u00e9solution:","text":"<ol> <li>Calcul des d\u00e9riv\u00e9es n\u00e9cessaires:     </li> <li>\u00c9valuation \u00e0 :</li> <li> </li> <li>D\u00e9veloppement:    [    \\sin(x) \\approx x - \\frac{x^3}{6} +</li> </ol> <p>\\frac{x^5}{120}    ]</p>"},{"location":"cours_mathmt/#5-courbes-donner-lequation-cartesienne-dune-courbe-a-partir-dun-vecteur","title":"5. Courbes: Donner l'\u00c9quation Cart\u00e9sienne d'une Courbe \u00e0 partir d'un Vecteur","text":"<p>Exemple: Trouver l'\u00e9quation cart\u00e9sienne de la courbe repr\u00e9sent\u00e9e par le vecteur position  .</p>"},{"location":"cours_mathmt/#resolution_4","title":"R\u00e9solution:","text":"<ol> <li>Param\u00e9trisation:</li> <li> ,  </li> <li>\u00c9limination de :</li> <li> </li> </ol>"}]}