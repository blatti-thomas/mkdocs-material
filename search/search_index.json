{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Page d'accueil","text":""},{"location":"#page-daccueil","title":"Page d'accueil","text":"<p>Thomas Blatti (Thomas.Blatti@heig-vd.ch)  </p> <p>Ce site est con\u00e7u comme un outil de stockage de prise de notes  pour les cours. Il permet de cr\u00e9er, \u00e9diter et organiser  facilement des notes de cours dans un format structur\u00e9.  Adapt\u00e9 pour les \u00e9tudiants qui souhaitent optimiser leur  gestion de notes, cet outil vise \u00e0 am\u00e9liorer l'efficacit\u00e9  de l'apprentissage et la r\u00e9vision.</p>"},{"location":"#sommaires","title":"Sommaires :","text":"<p>Prise de notes language C</p>"},{"location":"cours_info_C/","title":"Prise de notes en C","text":""},{"location":"cours_info_C/#bibliotheques-standard-du-c","title":"Biblioth\u00e8ques Standard du C","text":""},{"location":"cours_info_C/#gestion-des-erreurs-et-assertions","title":"=== Gestion des Erreurs et Assertions ===","text":"<pre><code>#include &lt;assert.h&gt; --&gt; Gestion des assertions \n</code></pre> <pre><code>#include &lt;errno.h&gt; --&gt; Codes d'erreur standard \n</code></pre>"},{"location":"cours_info_C/#types-et-limites","title":"=== Types et Limites ===","text":"<pre><code>#include &lt;complex.h&gt; --&gt; Op\u00e9rations sur des nombres complexes \n</code></pre> <pre><code>#include &lt;ctype.h&gt; --&gt; Fonctions de test et de mappage de caract\u00e8res    \n</code></pre> <pre><code>#include &lt;float.h&gt; --&gt; Limites des types \u00e0 virgule flottante    \n</code></pre> <pre><code>#include &lt;inttypes.h&gt; --&gt; Types entiers avec largeur fixe \n</code></pre> <pre><code>#include &lt;limits.h&gt; --&gt; Limites des types fondamentaux   \n</code></pre> <pre><code>#include &lt;stdbool.h&gt; --&gt; Types bool\u00e9en \n</code></pre> <pre><code>#include &lt;stddef.h&gt; --&gt; D\u00e9finitions de types et de macros g\u00e9n\u00e9rales  \n</code></pre> <pre><code>#include &lt;stdint.h&gt; --&gt; Types entiers \u00e0 largeur fixe  \n</code></pre>"},{"location":"cours_info_C/#localisation-et-environnement","title":"=== Localisation et Environnement ===","text":"<pre><code>#include &lt;locale.h&gt; --&gt; Localisation \n</code></pre> <pre><code>#include &lt;fenv.h&gt; --&gt; Gestion de l'environnement flottant   \n</code></pre> <pre><code>#include &lt;setjmp.h&gt; --&gt; Gestion des rebonds d'environnement non local \n</code></pre> <pre><code>#include &lt;signal.h&gt; --&gt; Gestion des signaux \n</code></pre>"},{"location":"cours_info_C/#entreessorties-et-manipulation-de-chaines","title":"=== Entr\u00e9es/Sorties et Manipulation  de Cha\u00eenes ===","text":"<pre><code>#include &lt;stdio.h&gt; --&gt; Entr\u00e9e/Sortie  \n</code></pre> <pre><code>#include &lt;stdlib.h&gt; --&gt; Utilitaires g\u00e9n\u00e9raux\n</code></pre> <pre><code>#include &lt;string.h&gt; --&gt; Manipulation de cha\u00eenes \n</code></pre>"},{"location":"cours_info_C/#fonctions-mathematiques","title":"=== Fonctions Math\u00e9matiques ===","text":"<pre><code>#include &lt;math.h&gt; --&gt; Fonctions math\u00e9matiques   \n</code></pre> <pre><code>#include &lt;tgmath.h&gt; --&gt; Fonctions math\u00e9matiques g\u00e9n\u00e9riques\n</code></pre>"},{"location":"cours_info_C/#gestion-du-temps","title":"=== Gestion du Temps ===","text":"<pre><code>#include &lt;time.h&gt; --&gt; Fonctions li\u00e9es au temps\n</code></pre>"},{"location":"cours_info_C/#arguments-variables","title":"=== Arguments Variables ===","text":"<pre><code>#include &lt;stdarg.h&gt; --&gt; Gestion des arguments \u00e0 nombre variable\n</code></pre>"},{"location":"cours_info_C/#types-de-variables-du-c","title":"Types de variables du C","text":"<pre><code>char a;  --&gt; Entier sur 8 bits utilis\u00e9 pour des caract\u00e8res.\n\nshort b; --&gt; short int: Entier en g\u00e9n\u00e9ral sur 16 bits.\n\nint c;   --&gt; Entier en g\u00e9n\u00e9ral sur 16 ou 32 bits, d\u00e9pendant du syst\u00e8me et du compilateur.\n\nlong d;\n\nlong int e; --&gt; Entier en g\u00e9n\u00e9ral sur 32 bits.\n\nlong long f;\n\nlong long int g; --&gt; Entier sur 64 bits.\n</code></pre>"},{"location":"cours_info_C/#types-a-virgule-flottante","title":"=== Types \u00e0 Virgule Flottante ===","text":"<pre><code>float h; --&gt; Approximation de r\u00e9els, sur 32 bits\n            (1 bit de signe, 8 bits pour l'exposant et 23 bits pour la fraction).\n\ndouble i; --&gt; Approximation de r\u00e9els sur 64 bits (1 bit de signe, 11 bits\n              pour l'exposant et 52 bits pour la fraction).\n\nlong double j; --&gt; Approximation de r\u00e9els sur min. 80 bits, mais souvent\n                   128 bits (1 bit de signe, 15 bits pour l'exposant et 112 bits pour la fraction).\n</code></pre>"},{"location":"cours_info_C/#formatage-pour-printf-en-c","title":"Formatage pour printf en C","text":"<pre><code>  * %d, %i      : int en base 10  \n  * %c          : caract\u00e8re donn\u00e9 par son code de type int  \n  * %f          : double, par d\u00e9faut 6 chiffres significatifs  \n  * %e, %E      : double en notation scientifique avec e ou E  \n  * %g, %G      : choix automatique entre %f et %e ou entre %f et %E  \n  * %s          : cha\u00eene de caract\u00e8res  \n  * %u          : unsigned int  \n  * %o, %x, %X  : int affich\u00e9e en octal ou en hexad\u00e9cimal  \n  * %p          : adresse  \n  * %%          : le caract\u00e8re % lui-m\u00eame  \n</code></pre>"},{"location":"cours_info_C/#flags","title":"=== Flags ===","text":"<pre><code>- (flag)    : alignement \u00e0 gauche\n+ (flag)    : nombres imprim\u00e9s avec le signe (sinon seul le signe n\u00e9gatif est imprim\u00e9)\n0 (flag)    : ajoute des z\u00e9ros devant\n# (flag)    : avec type o, x, et X force l'\u00e9criture de 0, 0x ou 0X\n\ndevant. Avec f, e, E force le point d\u00e9cimal.\n\nWidth:\nnombre ou * : nombre minimum de caract\u00e8res utilis\u00e9s pour l\u2019impression (ajout d'espaces)\n\nPrecision:\n.nombre ou *: nombre de chiffres apr\u00e8s la virgule\n\nLength:\nl           : pour un entier long (ou L pour un long double), h pour un entier court\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-manipulation-de-fichiers-en-c","title":"Fonctions de Manipulation de Fichiers en C","text":"<pre><code>int fputc(int c, FILE *fp); --&gt; \u00c9crit un caract\u00e8re 'c' dans le fichier point\u00e9 par 'fp'.\n                                 Retourne le caract\u00e8re \u00e9crit en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>int fgetc(FILE *fp); --&gt; Lit et retourne le prochain caract\u00e8re sous forme d'int\n                         depuis le fichier point\u00e9 par 'fp' ou EOF en cas d'erreur ou de fin de fichier.\n</code></pre> <pre><code>int ungetc(int char, FILE *fp); --&gt; Remet le caract\u00e8re 'char' dans le flux de 'fp', le rendant\n                                    disponible pour la prochaine lecture avec fgetc(). Retourne\n                                    le caract\u00e8re en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>int fputs(const char *s, FILE *fp); --&gt; \u00c9crit la cha\u00eene 's' dans le fichier point\u00e9\n                                          par 'fp' (le '\\n' n'est pas n\u00e9cessaire). Retourne une\n                                          valeur non n\u00e9gative en cas de succ\u00e8s, sinon EOF.\n</code></pre> <pre><code>char *fgets(char *buf, int n, FILE *fp); --&gt; Lit au maximum 'n-1' caract\u00e8res depuis le fichier 'fp', les\n                                             stocke dans 'buf', et ajoute un '\\0' final. S'arr\u00eate \u00e0 '\\n'\n                                             ou \u00e0 la fin du fichier. Retourne 'buf' en cas de succ\u00e8s, sinon NULL.\n</code></pre> <pre><code>int fprintf(FILE *fp, const char *format, ...); --&gt; \u00c9crit des donn\u00e9es format\u00e9es dans le fichier 'fp' selon le 'format'\n                                                     sp\u00e9cifi\u00e9, comme printf mais dans un fichier. Retourne le nombre de\n                                                     caract\u00e8res \u00e9crits, ou une valeur n\u00e9gative en cas d'\u00e9chec.\n</code></pre> <pre><code>int fscanf(FILE *fp, const char *format, ...); --&gt; Lit des donn\u00e9es format\u00e9es depuis le fichier 'fp' selon le 'format'\n                                                    sp\u00e9cifi\u00e9, comme scanf mais depuis un fichier. Retourne le\n                                                    nombre d'\u00e9l\u00e9ments lus, 0 en cas d'erreur, ou EOF pour une fin de fichier.\n</code></pre> <pre><code>void rewind(FILE *fp); --&gt;Repositionne le curseur de fichier 'fp' au d\u00e9but du fichier.\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-gestion-avancee-des-fichiers-en-c","title":"=== Fonctions de Gestion Avanc\u00e9e des Fichiers en C ===","text":"<pre><code>int fflush(FILE *fp); --&gt; Vide le buffer de sortie du fichier point\u00e9 par 'fp' et\n                            \u00e9crit toutes les donn\u00e9es en attente.\n                            Retourne 0 en cas de succ\u00e8s, EOF en cas d'erreur.\n</code></pre> <pre><code>fflush(NULL); --&gt; Vide tous les buffers de sortie de tous les fichiers ouverts.\n</code></pre> <pre><code>int remove(const char *filename); --&gt; Supprime le fichier d\u00e9sign\u00e9 par 'filename'. Retourne 0 en cas\n                                        de succ\u00e8s, -1 en cas d'erreur et\n                                        d\u00e9finit errno.\n</code></pre> <pre><code>int rename(const char *old_filename, const char *new_filename); --&gt; Renomme le fichier 'old_filename' en 'new_filename'. Retourne 0\n                                                                      en cas de succ\u00e8s, -1 en cas\n                                                                      d'erreur et d\u00e9finit errno.\n</code></pre> <pre><code>FILE *tmpfile(void); --&gt; Cr\u00e9e un fichier temporaire en mode \"wb+\" qui sera supprim\u00e9\n                           automatiquement \u00e0 la fin de l'ex\u00e9cution du programme.\n                           Retourne un pointeur vers ce fichier en cas de succ\u00e8s, ou NULL en cas d'\u00e9chec.\n</code></pre>"},{"location":"cours_info_C/#fonctions-de-verification-et-de-reinitialisation-de-letat-des-fichiers-en-c","title":"=== Fonctions de V\u00e9rification et de R\u00e9initialisation de l'\u00c9tat des Fichiers en C ===","text":"<pre><code>void clearerr(FILE *fp); --&gt; Efface les indicateurs d'erreur et de fin de fichier associ\u00e9s au\n                               fichier point\u00e9 par 'fp'.\n</code></pre> <pre><code>int feof(FILE *fp); --&gt; Teste l'indicateur de fin de fichier pour le fichier point\u00e9 par 'fp' et\n                          renvoie un r\u00e9sultat non nul si celui-ci est positionn\u00e9, 0 sinon.\n</code></pre> <pre><code>int ferror(FILE *fp); --&gt; Teste l'indicateur d'erreur pour le fichier point\u00e9 par 'fp' et renvoie un\n                            r\u00e9sultat non nul si celui-ci est positionn\u00e9, 0 sinon.\n</code></pre>"},{"location":"cours_info_C/#structures-et-creation-de-types-en-c","title":"Structures et Cr\u00e9ation de Types en C","text":"<ul> <li> <p>D\u00e9finition d'une structure   <code>struct NomStructure {       type membre1;         --&gt; Permet de regrouper plusieurs variables de types diff\u00e9rents sous le m\u00eame type.       type membre2;      };</code></p> </li> <li> <p>Cr\u00e9ation d'une instance de structure    <code>struct NomStructure variable; --&gt; D\u00e9clare une variable de type 'struct NomStructure'.</code></p> </li> <li> <p>Acc\u00e8s aux membres d'une structure    <code>variable.membre1 = valeur; --&gt; Acc\u00e8de et modifie le membre 'membre1' de la structure 'variable'.</code></p> </li> <li> <p>Pointeur sur une structure    <code>struct NomStructure *ptr = &amp;variable; --&gt; Cr\u00e9e un pointeur 'ptr' vers la structure 'variable'.</code></p> </li> <li> <p>Acc\u00e8s aux membres d'une structure via un pointeur    <code>ptr-&gt;membre1 = valeur; --&gt; Acc\u00e8de et modifie le membre 'membre1' via le pointeur 'ptr'.</code></p> </li> <li> <p>Typedef pour les structures    <code>typedef struct NomStructure AliasStructure; --&gt; Permet de d\u00e9finir un alias 'AliasStructure' pour 'struct NomStructure'.</code></p> </li> <li> <p>Utilisation de l'alias de structure    <code>AliasStructure nouvelleVariable; --&gt; D\u00e9clare une variable 'nouvelleVariable' de type 'AliasStructure'.</code></p> </li> <li> <p>D\u00e9finition d'un type enum    <code>enum NomEnum { CONST1, CONST2, ... }; --&gt; Permet de d\u00e9finir un ensemble de constantes enti\u00e8res nomm\u00e9es.</code></p> </li> <li> <p>Utilisation d'un enum    <code>enum NomEnum variableEnum = CONST1; --&gt; D\u00e9clare une variable 'variableEnum' de type 'enum NomEnum' et                                           l'initialise avec 'CONST1'.</code></p> </li> </ul>"}]}